<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!-- <link rel="import" href="../../polymer/polymer.html"> -->
<link rel="import" href="../../iron-media-query/iron-media-query.html">
<!-- <link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html"> -->
<link rel="import" href="../app-drawer/app-drawer.html">

<!--
app-drawer-layout is a wrapper element that positions an app-drawer and other content. When
the viewport width is smaller than `responsiveWidth`, this element changes to narrow layout.
In narrow layout, the drawer will be stacked on top of the main content. The drawer will slide
in/out to hide/reveal the main content.

By default the drawer is aligned to the start, which is left in LTR layouts:

```html
<app-drawer-layout>
  <app-drawer>
    drawer content
  </app-drawer>
  <div>
    main content
  </div>
</app-drawer-layout>
```

Align the drawer at the end:

```html
<app-drawer-layout>
  <app-drawer align="end">
     drawer content
  </app-drawer>
  <div>
    main content
  </div>
</app-drawer-layout>
```

With an app-header-layout:

```html
<app-drawer-layout>
  <app-drawer>
    drawer-content
  </app-drawer>
  <app-header-layout>
    <app-header>
      <app-toolbar>
        <div title>App name</div>
      </app-toolbar>
    </app-header>

    main content

  </app-header-layout>
</app-drawer-layout>
```

Add the `drawer-toggle` attribute to elements inside `app-drawer-layout` that toggle the drawer on tap events:

```html
<app-drawer-layout>
  <app-drawer>
    drawer-content
  </app-drawer>
  <app-header-layout>
    <app-header>
      <app-toolbar>
        <paper-icon-button icon="menu" drawer-toggle></paper-icon-button>
        <div title>App name</div>
      </app-toolbar>
    </app-header>

    main content

  </app-header-layout>
</app-drawer-layout>
```

Add the `fullbleed` attribute to app-drawer-layout to make it fit the size of its container:

```html
<app-drawer-layout fullbleed>
  <app-drawer>
     drawer content
  </app-drawer>
  <div>
    main content
  </div>
</app-drawer-layout>
```

### Styling

Custom property                          | Description                          | Default
-----------------------------------------|--------------------------------------|---------
`--app-drawer-layout-content-transition` | Transition for the content container | none

@group App Elements
@element app-drawer-layout
@demo app-drawer-layout/demo/simple-drawer.html Simple Demo
@demo app-drawer-layout/demo/two-drawers.html Two drawers
-->

<dom-module id="app-drawer-layout">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([fullbleed]) {
        @apply(--layout-fit);
      }

      #contentContainer {
        position: relative;

        height: 100%;

        transition: var(--app-drawer-layout-content-transition, none);
      }

      /* This will no longer work if [drawer-toggle] is not a direct child of app-drawer-layout. */
      /* Also, style recalc bug in WebKit nightly http://jsbin.com/pureji/edit?html,output */
      #contentContainer:not(.narrow) > ::slotted([drawer-toggle]) {
        display: none;
      }
    </style>

    <div id="contentContainer">
      <!-- Children with specified slot attributes will not be distributed here. -->
      <slot></slot>
      <content select=":not(app-drawer)"></content>
    </div>

    <slot id="drawerSlot" name="drawer"></slot>
    <content id="drawerContent" select="app-drawer"></content>

    <!-- For some reason, the iron-media-query in the template is not upgraded. -->
    <!-- <iron-media-query
        query="[[_computeMediaQuery(forceNarrow, responsiveWidth)]]"
        on-query-matches-changed="_onQueryMatchesChanged"></iron-media-query> -->
  </template>

  <script>
    // Polymer({
    //   is: 'app-drawer-layout',

    class AppDrawerLayout extends HTMLElement {
      // behaviors: [
      //   Polymer.IronResizableBehavior
      // ],

      // properties: {
        /**
         * If true, ignore `responsiveWidth` setting and force the narrow layout.
         */
        // forceNarrow: {
        //   type: Boolean,
        //   value: false
        // }

        /**
         * If the viewport's width is smaller than this value, the panel will change to narrow
         * layout. In the mode the drawer will be closed.
         */
        // responsiveWidth: {
        //   type: String,
        //   value: '640px'
        // },

        /**
         * Returns true if it is in narrow layout. This is useful if you need to show/hide
         * elements based on the layout.
         */
        // narrow: {
        //   type: Boolean,
        //   readOnly: true,
        //   notify: true
        // }
      // },

      // listeners: {
      //   'tap': '_tapHandler',
      //   'app-drawer-reset-layout': 'resetLayout'
      // },

      // observers: [
      //   'resetLayout(narrow, isAttached)'
      // ],

      /**
       * A reference to the app-drawer element.
       *
       * @property drawer
       */
      get drawer() {
        var drawer;
        if (this.$.drawerSlot.assignedNodes) {
          drawer = this.$.drawerSlot.assignedNodes()[0];
        }
        // return drawer || this.$.drawerContent.getDistributedNodes()[0];
        return this.children[0]
      }

      stampTemplate(tagName) {
        var htmlImport = document.querySelector('link[rel=import][href*=' + tagName + ']');
        var domModule;
        // In CE v1, the constructor is synchronous and `htmlImport.import` won't be set in
        // polyfilled browsers, so use `document._currentScript` instead.
        if (htmlImport.import) {
          domModule = htmlImport.import.querySelector('dom-module#' + tagName);
        } else {
          domModule = document._currentScript.parentElement;
        }
        var template = domModule.querySelector('template');
        this.attachShadow ? this.attachShadow({ mode: 'open' }) : this.createShadowRoot();
        this.shadowRoot.appendChild(template.content.cloneNode(true /* deep */));
      }

      constructor() {
        super();
        this.createdCallback();
      }

      createdCallback() {
        this.stampTemplate('app-drawer-layout');

        this.$ = {};
        this.$.contentContainer = this.shadowRoot.querySelector('#contentContainer');
        this.$.drawerSlot = this.shadowRoot.querySelector('#drawerSlot');
        this.$.drawerContent = this.shadowRoot.querySelector('#drawerContent');
        this.$.mediaQuery = this.shadowRoot.appendChild(document.createElement('iron-media-query'));

        this.forceNarrow = this.getAttribute('force-narrow') !== null;
        this.responsiveWidth = this.getAttribute('responsive-width') || '640px';
        this.$.mediaQuery.query = this._computeMediaQuery(this.forceNarrow, this.responsiveWidth);
        this.narrow = this.$.mediaQuery.queryMatches;
      }

      connectedCallback() {
        this.attachedCallback();
      }

      attachedCallback() {
        this.isAttached = true;
        this.resetLayout();

        this.$.mediaQuery.addEventListener('query-matches-changed', this._onQueryMatchesChanged.bind(this));
        this.addEventListener('click', this._tapHandler.bind(this));
        this.addEventListener('app-drawer-reset-layout', this.resetLayout.bind(this));
      }

      _tapHandler(e) {
        var target = e.target;
        if (target && target.hasAttribute('drawer-toggle')) {
          this.drawer.toggle();
        }
      }

      resetLayout() {
        if (!this.isAttached) {
          return;
        }

        // Mock debounce
        // Async since we need for app-drawer to be attached so we can measure its width.
        window.setTimeout(_ => {
          var drawer = this.drawer;
          var contentContainer = this.$.contentContainer;

          if (this.narrow) {
            drawer.opened = drawer.persistent = false;
            contentContainer.classList.add('narrow');

            contentContainer.style.marginLeft = '';
            contentContainer.style.marginRight = '';
          } else {
            drawer.opened = drawer.persistent = true;
            contentContainer.classList.remove('narrow');

            var drawerWidth = this.drawer.getWidth();
            if (drawer.position == 'right') {
              contentContainer.style.marginLeft = '';
              contentContainer.style.marginRight = drawerWidth + 'px';
            } else {
              contentContainer.style.marginLeft = drawerWidth + 'px';
              contentContainer.style.marginRight = '';
            }
          }

          // this.notifyResize();
        }, 1);
      }

      _onQueryMatchesChanged(event) {
        this.narrow = event.detail.value;
        this.resetLayout();
      }

      _computeMediaQuery(forceNarrow, responsiveWidth) {
        return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
      }
    }

    if (window.customElements) {
      customElements.define('app-drawer-layout', AppDrawerLayout);
    } else {
      document.registerElement('app-drawer-layout', AppDrawerLayout);
    }
  </script>
</dom-module>
